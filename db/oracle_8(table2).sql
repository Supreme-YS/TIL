SELECT *
FROM LOCATION ;


CREATE TABLE TEST_COMPOSITE_PK (
    ID     VARCHAR2(50),
    NAME   VARCHAR2(50),
    SALARY NUMBER CHECK (SALARY > 0),--0보다 큰 SALARY 값을 받겠다. 음수 X 
                                     --NUMBER(7,2) : 7자리의 NUMBER 값 중 2자리는 실수형을 쓰겠다.
    GENDER CHAR(1) CHECK (GENDER IN ('M', 'F')), --M 또는 F 값만 받겠다. 
    PRIMARY KEY (ID, NAME)
)

INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', -100, 'M') --check constraint (HR.SYS_C007085) violated 발생/양수입력
INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', 100, '?') --check constraint (HR.SYS_C007086) violated 발생/M또는F값입력
INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', 100, 'm') --check constraint (HR.SYS_C007086) violated 발생/대소문자구분
INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', 100, 'M') --정상입력

SELECT *
FROM TEST_COMPOSITE_PK

DROP TABLE TEST_COMPOSITE_FK;

CREATE TABLE TEST_COMPOSITE_FK(
    PID      VARCHAR2(50) PRIMARY KEY,
    ID       VARCHAR2(50) ,
    NAME     VARCHAR2(50) ,
    FOREIGN KEY (ID, NAME) REFERENCES TEST_COMPOSITE_PK (ID, NAME)
)

INSERT INTO TEST_COMPOSITE_FK VALUES('P001', 'YSSIM', '심영석')

SELECT *
FROM TEST_COMPOSITE_FK

----------------------PRACTICE

CREATE TABLE TEST_S1(
    SID    VARCHAR(50) PRIMARY KEY,
    PHONE  NUMBER
)

CREATE TABLE TEST_S2(
    TID    VARCHAR(50) PRIMARY KEY,
    NAME   VARCHAR(50) DEFAULT 'DEFAULT'
)

CREATE TABLE TEST_CHILD(
    CID    VARCHAR(50) PRIMARY KEY,
    SID    VARCHAR(50) REFERENCES TEST_S1(SID),
    TID    VARCHAR(50) REFERENCES TEST_S2(TID)
)

SELECT *
FROM TEST_S1

INSERT INTO TEST_S1 VALUES('SID', 01038227541)
INSERT INTO TEST_S2 VALUES('TID', '심영석')
INSERT INTO TEST_CHILD VALUES('CID', 'SID', 'TID')


--VIEW
--CREATE [OR REPLACE] VIEW VIEW_NAME(ALIAS) AS SUBQUERY ;

CREATE OR REPLACE VIEW V_EMP(NAME, DEPT)
AS SELECT EMP_NAME, DEPT_ID 
   FROM EMPLOYEE
   WHERE DEPT_ID = '90';

SELECT *
FROM V_EMP ;

-- 직급이 '사원'인 직원의 이름, 부서이름, 직급을 갖는 V_EMP_DEPT_JOB 뷰를 작성하시오

CREATE OR REPLACE VIEW V_EMP_DEPT_JOB("이름", "부서이름", "직급")
AS SELECT EMP_NAME, DEPT_NAME, JOB_TITLE
   FROM EMPLOYEE
   JOIN JOB USING(JOB_ID)
   JOIN DEPARTMENT USING(DEPT_ID)
   WHERE JOB_TITLE = '사원' ;

SELECT *
FROM V_EMP_DEPT_JOB

-- VIEW 삭제
DROP VIEW V_EMP_DEPT_JOB ;

--SEQUENCE 객체
CREATE SEQUENCE TEST_SEQ
START WITH   300
INCREMENT BY 2
MAXVALUE     310
NOCYCLE
NOCACHE ;

SELECT TEST_SEQ.NEXTVAL FROM DUAL;
SELECT TEST_SEQ.CURRVAL FROM DUAL;
DROP SEQUENCE TEST_SEQ

--18 문제
--TOP-N 분석 : 조건에 맞는 최상위 레코드 N개를 식별해야하는 경우 사용하는 쿼리 기법
--원리 1. 정렬 2. ROWNUM 3. 부여된 순번대로 필요한 만큼 식별


--부서별 평균급여보다 많은 급여를 받은 사원의 정보 중 사원이름, 급여를 조회하려고 한다.
--평균급여는 정수 3자리에서 올림
--FROM 절에서 SUBQUERY(INLINE VIEW)를 이용해서 작성

--메인서브쿼리
( SELECT EMP_NAME, SALARY
  FROM ( SELECT DEPT_ID,  ROUND(AVG(SALARY), -3) AS DAVG
         FROM EMPLOYEE 
         GROUP BY DEPT_ID ) INVIEW --INLINE VIEW니까 별칭을 그냥 INVIEW라고 줌.
  JOIN   EMPLOYEE E ON (E.DEPT_ID = INVIEW.DEPT_ID)
  WHERE  SALARY > INVIEW.DAVG 
--ORDER BY 3 DESC; --인덱스가 셔플되버린다.
  ORDER BY 2 DESC )


--서브쿼리!
SELECT DEPT_ID,  ROUND(AVG(SALARY), -3) AS DAVG
FROM EMPLOYEE 
GROUP BY DEPT_ID

--메인처럼 보이는 쿼리를 서브쿼리로 한번 더 활용

SELECT ROWNUM, EMP_NAME, SALARY
FROM ( SELECT EMP_NAME, SALARY
       FROM ( SELECT DEPT_ID,  ROUND(AVG(SALARY), -3) AS DAVG
              FROM EMPLOYEE 
              GROUP BY DEPT_ID ) INVIEW
       JOIN   EMPLOYEE E ON (E.DEPT_ID = INVIEW.DEPT_ID)
       WHERE  SALARY > INVIEW.DAVG 
       ORDER BY 2 DESC )
WHERE ROWNUM = 1;

-- RANK() - WITHIN, OVER
SELECT *
FROM  ( SELECT EMP_NAME, SALARY,
               RANK() OVER(ORDER BY SALARY DESC) AS R
        FROM EMPLOYEE)
WHERE R <= 5;

-- DML (INSERT, UPDATE, DELETE )
-- UPDATE 구문(수정)
UPDATE TABLE_NAME
SET    [COLUMN_NAME = VALUE , ]
WHERE  CONDITION;
--DELETE 레코드 삭제, DROP 테이블 삭제
DELETE FROM TABLE_NAME
WHERE  CONDITION;

CREATE TABLE TEST_DML(
       ID       VARCHAR2(50) PRIMARY KEY,
       PWD      VARCHAR2(50) NOT NULL,
       NAME     VARCHAR2(50) NOT NULL,
       SALARY   NUMBER       CHECK( SALARY > 0 ),
       MARRIAGE CHAR(1)      CHECK( MARRIAGE IN ('Y', 'N'))
)

INSERT INTO TEST_DML VALUES('YSSIM', 'YSSIM', '심영석', 100, 'N')
INSERT INTO TEST_DML VALUES('SUPREME', 'ADMIN', '관리자', 100, 'Y')

UPDATE TEST_DML
SET    MARRIAGE = 'N', SALARY = 200
--WHERE  ID = 'YSSIM'; --WHERE 조건을 사용해야만 전체 다 데이터가 바뀌지 않는다. 특정 값만 업데이트 할 거니까.

DELETE
FROM TEST_DML  --이렇게 쓰면 전체 데이터가 날아간다.
WHERE ID = 'SUPREME' ; --특정 레코드 삭제를 위해 WHERE 절을 사용해서 조건을 입력해줘야 한다.

SELECT *
FROM TEST_DML;



