SELECT *
FROM LOCATION ;


CREATE TABLE TEST_COMPOSITE_PK (
    ID     VARCHAR2(50),
    NAME   VARCHAR2(50),
    SALARY NUMBER CHECK (SALARY > 0),--0보다 큰 SALARY 값을 받겠다. 음수 X 
                                     --NUMBER(7,2) : 7자리의 NUMBER 값 중 2자리는 실수형을 쓰겠다.
    GENDER CHAR(1) CHECK (GENDER IN ('M', 'F')), --M 또는 F 값만 받겠다. 
    PRIMARY KEY (ID, NAME)
)

INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', -100, 'M') --check constraint (HR.SYS_C007085) violated 발생/양수입력
INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', 100, '?') --check constraint (HR.SYS_C007086) violated 발생/M또는F값입력
INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', 100, 'm') --check constraint (HR.SYS_C007086) violated 발생/대소문자구분
INSERT INTO TEST_COMPOSITE_PK VALUES('YSSIM', '심영석', 100, 'M') --정상입력

SELECT *
FROM TEST_COMPOSITE_PK

DROP TABLE TEST_COMPOSITE_FK;

CREATE TABLE TEST_COMPOSITE_FK(
    PID      VARCHAR2(50) PRIMARY KEY,
    ID       VARCHAR2(50) ,
    NAME     VARCHAR2(50) ,
    FOREIGN KEY (ID, NAME) REFERENCES TEST_COMPOSITE_PK (ID, NAME)
)

INSERT INTO TEST_COMPOSITE_FK VALUES('P001', 'YSSIM', '심영석')

SELECT *
FROM TEST_COMPOSITE_FK

----------------------PRACTICE

CREATE TABLE TEST_S1(
    SID    VARCHAR(50) PRIMARY KEY,
    PHONE  NUMBER
)

CREATE TABLE TEST_S2(
    TID    VARCHAR(50) PRIMARY KEY,
    NAME   VARCHAR(50) DEFAULT 'DEFAULT'
)

CREATE TABLE TEST_CHILD(
    CID    VARCHAR(50) PRIMARY KEY,
    SID    VARCHAR(50) REFERENCES TEST_S1(SID),
    TID    VARCHAR(50) REFERENCES TEST_S2(TID)
)

SELECT *
FROM TEST_S1

INSERT INTO TEST_S1 VALUES('SID', 01038227541)
INSERT INTO TEST_S2 VALUES('TID', '심영석')
INSERT INTO TEST_CHILD VALUES('CID', 'SID', 'TID')


--VIEW
--CREATE [OR REPLACE] VIEW VIEW_NAME(ALIAS) AS SUBQUERY ;

CREATE OR REPLACE VIEW V_EMP(NAME, DEPT)
AS SELECT EMP_NAME, DEPT_ID 
   FROM EMPLOYEE
   WHERE DEPT_ID = '90';

SELECT *
FROM V_EMP ;

-- 직급이 '사원'인 직원의 이름, 부서이름, 직급을 갖는 V_EMP_DEPT_JOB 뷰를 작성하시오

CREATE OR REPLACE VIEW V_EMP_DEPT_JOB("이름", "부서이름", "직급")
AS SELECT EMP_NAME, DEPT_NAME, JOB_TITLE
   FROM EMPLOYEE
   JOIN JOB USING(JOB_ID)
   JOIN DEPARTMENT USING(DEPT_ID)
   WHERE JOB_TITLE = '사원' ;

SELECT *
FROM V_EMP_DEPT_JOB

-- VIEW 삭제
DROP VIEW V_EMP_DEPT_JOB ;

--SEQUENCE 객체
CREATE SEQUENCE TEST_SEQ
START WITH   300
INCREMENT BY 2
MAXVALUE     310
NOCYCLE
NOCACHE ;

SELECT TEST_SEQ.NEXTVAL FROM DUAL;
SELECT TEST_SEQ.CURRVAL FROM DUAL;
DROP SEQUENCE TEST_SEQ

--18 문제
--TOP-N 분석 : 조건에 맞는 최상위 레코드 N개를 식별해야하는 경우 사용하는 쿼리 기법
--원리 1. 정렬 2. ROWNUM 3. 부여된 순번대로 필요한 만큼 식별


--부서별 평균급여보다 많은 급여를 받은 사원의 정보 중 사원이름, 급여를 조회하려고 한다.
--평균급여는 정수 3자리에서 올림
--FROM 절에서 SUBQUERY(INLINE VIEW)를 이용해서 작성


--서브쿼리!
SELECT DEPT_ID,  ROUND(AVG(SALARY), -3) AS DAVG
FROM EMPLOYEE 
GROUP BY DEPT_ID












-- TOP-N 분석

SELECT  EMP_NAME , JOB_TITLE , SALARY
FROM    (SELECT  JOB_ID, TRUNC(AVG(SALARY) , -5) AS JOBAVG
         FROM    EMPLOYEE
         GROUP BY    JOB_ID) V
JOIN    EMPLOYEE E ON(V.JOB_ID = E.JOB_ID AND V.JOBAVG = E.SALARY)
JOIN    JOB J ON(E.JOB_ID = J.JOB_ID)


